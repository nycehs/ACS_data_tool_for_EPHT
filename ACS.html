<!DOCTYPE html>
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="" />
    <meta name="author" content="" />
    
    <link rel="stylesheet" href="style.css" />
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fetch-retry@latest"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
    <script src="geography_lookupNew.js"></script>
    <script src="queue.v1.min.js"></script>
    <script src="modernizr-custom.js"></script>
    <script src="excellentexport.js"></script>

</head>

<!--Arquero-->
<script src="https://cdn.jsdelivr.net/npm/arquero@latest"></script>

<body>
    <div id="controls">
        <label>Indicator:</label>
        <select id='ind_options'></select>

        <label>Year:</label>
        <select id='year_options'>

            <!-- add new years here -->
            <option value="2021">2017-2021</option>
            <option value="2020">2016-2020</option>
            <option value="2019">2015-2019</option>
            <option value="2018">2014-2018</option>
            <option value="2017">2013-2017</option>
            <option value="2016">2012-2016</option>
            <option value="2015">2011-2015</option>
            <option value="2014">2010-2014</option>
            <option value="2013">2009-2013</option>
            <option value="2012">2008-2012</option>
            <option value="2011">2007-2011</option>
        </select>

        <a href="#" class="myButton" id="get_data">Get Data</a>
        <a href="#" class="export myButton" id="exportChrome" style="display:none">Export Table to CSV</a>
        <a href="#" class="export myButton" id="exportIE" style="display:none" onclick="return ExcellentExport.csv(this, 'datatableCsv');">Export Table to CSV</a>
        <a href="ACS_Documentation.pdf" style="margin: 0px 0px 10px 10px;" id="download">Documentation</a>
        <input id="chkrank" type="checkbox" name="vehicle" />Include Rank<br>
    </div>


    <div id='tab_loc' class="CSSTableGenerator"></div>
</body>

<script>


    //===========================================================================//
    // setting initial variable values
    //===========================================================================//
    
    // Census API 5-year ACS URL

    var api_url = 'https://api.census.gov/data';
    var my_key = 'c8b757f7e16f108647304131056db5bb63ba2e93';

    //---------------------------------------------------------------------------//
    // indicators whose definitions and variables haven't changed
    //---------------------------------------------------------------------------//
    /* 
        ACS variable names are {table}_{row}, so when the row number of an estimate changes, 
        the variable name changes also. If we keep track of those changes, we can account 
        for them. So I recoded the census_param and race_var objects to include the 
        correct variable names for specified time periods, then included a test so that 
        census_var includes the correct variables. 
    */

    // denom = complete denominator
    // denom2 = combined with number to form complete denominator

    var census_param = [
    {
        indicator: "Race and ethnicity", category: "race_vars"
    },
    {
        indicator: "Total population", table: "TOTAL POPULATION", source: 'acs/acs5', category: "population",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B01003_001E", label: "Estimate!!Total", type: "num" }
            ]
        }
        ]
    }, 
    {
        indicator: "Housing Units", table: "HOUSING UNITS", source: 'acs/acs5', category: "housing",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B25001_001E", label: "Estimate!!Total", type: "num" }
            ]
        }
        ]
    }, 
    {
        indicator: "Neighborhood poverty", table: "POVERTY STATUS IN THE PAST 12 MONTHS BY SEX BY AGE", source: 'acs/acs5', category: "poverty",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B17001_002E", label: "Estimate!!Total!!Income in the past 12 months below poverty level", type: "num" },
            { name: "B17001_001E", label: "Estimate!!Total", type: "denom" }
            ]
        }
        ]
    },
    // {
    //     indicator: "Poverty TOTAL", table: "POVERTY STATUS IN THE PAST 12 MONTHS BY AGE", source: 'acs/acs5',
    //     time_period: [
    //     {
    //         min: 2010, 
    //         max: 2021,
    //         variables: [
    //         { name: "B17001_001E", label: "Estimate!!Total", type: "num" }
    //         ]
    //     }
    //     ]
    // },
    {
        indicator: "Child poverty (under age 5)", table: "POVERTY STATUS IN THE PAST 12 MONTHS BY SEX BY AGE", source: 'acs/acs5', category: "under_5_poverty",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B17001_004E", label: "Estimate!!Total!!Income in the past 12 months below poverty level!!Male!!Under 5 years", type: "num" },
            { name: "B17001_033E", label: "Estimate!!Total!!Income in the past 12 months at or above poverty level!!Male!!Under 5 years", type: "denom2" },

            { name: "B17001_018E", label: "Estimate!!Total!!Income in the past 12 months below poverty level!!Female!!Under 5 years", type: "num" },
            { name: "B17001_047E", label: "Estimate!!Total!!Income in the past 12 months at or above poverty level!!Female!!Under 5 years", type: "denom2" }
            ]
        }
        ]
    },
    {
        indicator: "Unemployment", table: "EMPLOYMENT STATUS FOR THE POPULATION 16 YEARS AND OVER", source: 'acs/acs5', category: "unemployment",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B23025_005E", label: "Estimate!!Total!!In labor force!!Civilian labor force!!Unemployed", type: "num" },
            { name: "B23025_003E", label: "Estimate!!Total!!In labor force!!Civilian labor force", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Rent-burdened households", table: "GROSS RENT AS A PERCENTAGE OF HOUSEHOLD INCOME IN THE PAST 12 MONTHS", source: 'acs/acs5', category: "rent",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B25070_007E", label: "Estimate!!Total!!30.0 to 34.9 percent", type: "num" },
            { name: "B25070_008E", label: "Estimate!!Total!!35.0 to 39.9 percent", type: "num" },
            { name: "B25070_009E", label: "Estimate!!Total!!40.0 to 49.9 percent", type: "num" }, 
            { name: "B25070_010E", label: "Estimate!!Total!!50.0 percent or more", type: "num" },
            { name: "B25070_001E", label: "Estimate!!Total", type: "denom" }
            ]
        }
        ]
    },
    // {
    //     indicator: "Older adults living alone", table: "LIVING ARRANGEMENTS OF ADULTS 18 YEARS AND OVER BY AGE", source: 'acs/acs5', 
    //     time_period: [
    //     {
    //         min: 2015, 
    //         max: 2021,
    //         variables: [
    //         { name: "B09021_023E", label: "Estimate!!Total!!65 years and over!!Lives alone", type: "num" }, 
    //         { name: "B09021_022E", label: "Estimate!!Total!!65 years and over", type: "denom" } 
    //         ]
    //     }
    //     ]
    // },
    {
        indicator: "Older adults living alone", table: "Relationship by Household Type (Including Living Alone) for the Population 65 Years and Over", source: 'acs/acs5', category: "living_alone",
        time_period: [
        {
            min: 2010, 
            max: 2011,
            variables: [
            { name: "B09017_014E", label: "Estimate!!Total!!In households!!In nonfamily households!!Householder!!Male!!Living alone", type: "num" },
            { name: "B09017_017E", label: "Estimate!!Total!!In households!!In nonfamily households!!Householder!!Female!!Living alone", type: "num" },
            { name: "B09017_001E", label: "Estimate!!Total:", type: "denom" }
            ]
        },
        {
            min: 2012, 
            max: 2021,
            variables: [
            { name: "B09020_015E", label: "Estimate!!Total!!In households!!In nonfamily households!!Householder!!Male!!Living alone", type: "num" },
            { name: "B09020_018E", label: "Estimate!!Total!!In households!!In nonfamily households!!Householder!!Female!!Living alone", type: "num" },
            { name: "B09020_001E", label: "Estimate!!Total", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Very old homes", table: "YEAR STRUCTURE BUILT", source: 'acs/acs5', category: "1950_homes",
        time_period: [
        {
            min: 2010, 
            max: 2014,
            variables: [
            { name: "B25034_010E", label: "Estimate!!Total!!Built 1939 or earlier", type: "num" },
            { name: "B25034_009E", label: "Estimate!!Total!!Built 1940 to 1949", type: "num" },
            { name: "B25034_001E", label: "Estimate!!Total", type: "denom2" }
            ]
        },
        {
            min: 2015, 
            max: 2021,
            variables: [
            { name: "B25034_011E", label: "Estimate!!Total!!Built 1939 or earlier", type: "num" },
            { name: "B25034_010E", label: "Estimate!!Total!!Built 1940 to 1949", type: "num" },
            { name: "B25034_001E", label: "Estimate!!Total", type: "denom2" }
            ]
        }
        ]
    },
    {
        indicator: "Owner-occupied homes", table: "SELECTED HOUSING CHARACTERISTICS", source: 'acs/acs5/profile', category: "owner_occupied",
        time_period: [
        {
            min: 2010, 
            max: 2014,
            variables: [
            { name: "DP04_0045E", label: "Estimate!!HOUSING TENURE!!Occupied housing units!!Owner-occupied", type: "num" },
            { name: "DP04_0044E", label: "Estimate!!HOUSING TENURE!!Occupied housing units", type: "denom" }
            ]
        },
        {
            min: 2015, 
            max: 2021,
            variables: [
            { name: "DP04_0046E", label: "Estimate!!HOUSING TENURE!!Occupied housing units!!Owner-occupied", type: "num" },
            { name: "DP04_0045E", label: "Estimate!!HOUSING TENURE!!Occupied housing units", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Foreign-born", table: "SELECTED SOCIAL CHARACTERISTICS IN THE UNITED STATES", source: 'acs/acs5/profile', category: "foreign_born",
        time_period: [
        {
            min: 2010, 
            max: 2018,
            variables: [
            { name: "DP02_0092E", label: "Estimate!!PLACE OF BIRTH!!Total population!!Foreign born", type: "num" },
            { name: "DP02_0086E", label: "Estimate!!PLACE OF BIRTH!!Total population", type: "denom" }
            ]
        },
        {
            min: 2019, 
            max: 2021,
            variables: [
            { name: "DP02_0093E", label: "Estimate!!PLACE OF BIRTH!!Total population!!Foreign born", type: "num" },
            { name: "DP02_0087E", label: "Estimate!!PLACE OF BIRTH!!Total population", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Household crowding", table: "SELECTED HOUSING CHARACTERISTICS", source: 'acs/acs5/profile', category: "crowding",
        time_period: [
        {
            min: 2010, 
            max: 2014,
            variables: [
            { name: "DP04_0077E", label: "Estimate!!OCCUPANTS PER ROOM!!Occupied housing units!!1.01 to 1.50", type: "num" },
            { name: "DP04_0078E", label: "Estimate!!OCCUPANTS PER ROOM!!Occupied housing units!!1.51 or more", type: "num" },
            { name: "DP04_0075E", label: "Estimate!!OCCUPANTS PER ROOM!!Occupied housing units", type: "denom" }
            ]
        },
        {
            min: 2015, 
            max: 2021,
            variables: [
            { name: "DP04_0078E", label: "Estimate!!OCCUPANTS PER ROOM!!Occupied housing units!!1.01 to 1.50", type: "num" },
            { name: "DP04_0079E", label: "Estimate!!OCCUPANTS PER ROOM!!Occupied housing units!!1.51 or more", type: "num" },
            { name: "DP04_0076E", label: "Estimate!!OCCUPANTS PER ROOM!!Occupied housing units", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Graduated high school", table: "SELECTED SOCIAL CHARACTERISTICS IN THE UNITED STATES", source: 'acs/acs5/profile', category: "high_school",
        time_period: [
        {
            min: 2010, 
            max: 2018,
            variables: [
            { name: "DP02_0061E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over!!High school graduate (includes equivalency)", type: "num" },
            { name: "DP02_0062E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over!!Some college no degree", type: "num" }, 
            { name: "DP02_0063E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over!!Associate's degree", type: "num" },
            { name: "DP02_0064E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over!!Bachelor's degree", type: "num" }, 
            { name: "DP02_0065E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over!!Graduate or professional degree", type: "num" },
            { name: "DP02_0058E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over", type: "denom" }
            ]
        },
        {
            min: 2019, 
            max: 2021,
            variables: [
            { name: "DP02_0062E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over!!High school graduate (includes equivalency)", type: "num" },
            { name: "DP02_0063E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over!!Some college no degree", type: "num" }, 
            { name: "DP02_0064E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over!!Associate's degree", type: "num" },
            { name: "DP02_0065E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over!!Bachelor's degree", type: "num" }, 
            { name: "DP02_0066E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over!!Graduate or professional degree", type: "num" },
            { name: "DP02_0059E", label: "Estimate!!EDUCATIONAL ATTAINMENT!!Population 25 years and over", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Limited English", table: "SELECTED SOCIAL CHARACTERISTICS IN THE UNITED STATES", source: 'acs/acs5/profile', category: "limited_english",
        time_period: [
        {
            min: 2010, 
            max: 2018,
            variables: [
            { name: "DP02_0113E", label: "Estimate!!LANGUAGE SPOKEN AT HOME!!Population 5 years and over!!Language other than English!!Speak English less than 'very well'", type: "num" },
            { name: "DP02_0110E", label: "Estimate!!LANGUAGE SPOKEN AT HOME!!Population 5 years and over", type: "denom" }
            ]
        },
        {
            min: 2019, 
            max: 2021,
            variables: [
            { name: "DP02_0114E", label: "Estimate!!LANGUAGE SPOKEN AT HOME!!Population 5 years and over!!Language other than English!!Speak English less than 'very well'", type: "num" },
            { name: "DP02_0111E", label: "Estimate!!LANGUAGE SPOKEN AT HOME!!Population 5 years and over", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Means of transportation to work", category: "transportation"
    },
    ];
    
    
    //---------------------------------------------------------------------------//
    // Means of transportation to work
    //---------------------------------------------------------------------------//

    var transportation = [
    {
        indicator: "Car, truck, or van", table: "MEANS OF TRANSPORTATION TO WORK", source: 'acs/acs5', category: "transportation",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B08301_002E", label: "Estimate!!Total!!Car, truck, or van", type: "num" },
            { name: "B08301_001E", label: "Estimate!!Total", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Public transportation", table: "MEANS OF TRANSPORTATION TO WORK", source: 'acs/acs5', category: "transportation",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B08301_010E", label: "Estimate!!Total!!Public transportation (excluding taxicab)", type: "num" },
            { name: "B08301_001E", label: "Estimate!!Total", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Bicycle", table: "MEANS OF TRANSPORTATION TO WORK", source: 'acs/acs5', category: "transportation",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B08301_018E", label: "Estimate!!Total!!Bicycle", type: "num" },
            { name: "B08301_001E", label: "Estimate!!Total", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Walked", table: "MEANS OF TRANSPORTATION TO WORK", source: 'acs/acs5', category: "transportation",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B08301_019E", label: "Estimate!!Total!!Walked", type: "num" }, 
            { name: "B08301_001E", label: "Estimate!!Total", type: "denom" }
            ]
        }
        ]
    },
    ]
    
    //---------------------------------------------------------------------------//
    // variables for race indicators
    //---------------------------------------------------------------------------//
    /*     
        Because we want to compare Hispanic vs. non-Hispanic, and people reporting 
        "Hispanic" can be of any race, we use the "race alone" variables under "Not 
        Hispanic or Latino", which ensures that our race categories are mutually 
        exclusive, i.e., they will sum to <= 100%. If we use the estimates under 
        "RACE!!One race", the counts could include people reporting "Hispanic" 
        (e.g., "White" and "Hispanic"), which would make the estimates higher, and
        probably sum to > 100%. 
    */
    
    var race_vars = [
    {
        indicator: "Hispanic alone (percent)", table: "ACS DEMOGRAPHIC AND HOUSING ESTIMATES", source: 'acs/acs5/profile', category: "race_vars",
        time_period: [
        {
            min: 2010, 
            max: 2016,
            variables: [
            { name: "DP05_0066E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population!!Hispanic or Latino (of any race)", type: "num" },
            { name: "DP05_0065E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population", type: "denom" }
            ]
        },
        {
            min: 2017, 
            max: 2021,
            variables: [
            { name: "DP05_0071E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population!!Hispanic or Latino (of any race)", type: "num" },
            { name: "DP05_0070E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "White alone (percent)", table: "ACS DEMOGRAPHIC AND HOUSING ESTIMATES", source: 'acs/acs5/profile', category: "race_vars",
        time_period: [
        {
            min: 2010, 
            max: 2016,
            variables: [
            { name: "DP05_0072E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population!!Not Hispanic or Latino!!White alone", type: "num" },
            { name: "DP05_0065E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population", type: "denom" }
            ]
        },
        {
            min: 2017, 
            max: 2021,
            variables: [
            { name: "DP05_0077E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population!!Not Hispanic or Latino!!White alone", type: "num" },
            { name: "DP05_0070E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Black alone (percent)", table: "ACS DEMOGRAPHIC AND HOUSING ESTIMATES", source: 'acs/acs5/profile', category: "race_vars",
        time_period: [
        {
            min: 2010, 
            max: 2016,
            variables: [
            { name: "DP05_0073E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population!!Not Hispanic or Latino!!Black or African American alone", type: "num" },
            { name: "DP05_0065E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population", type: "denom" }
            ]
        },
        {
            min: 2017, 
            max: 2021,
            variables: [
            { name: "DP05_0078E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population!!Not Hispanic or Latino!!Black or African American alone", type: "num" },
            { name: "DP05_0070E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Asian alone (percent)", table: "ACS DEMOGRAPHIC AND HOUSING ESTIMATES", source: 'acs/acs5/profile', category: "race_vars",
        time_period: [
        {
            min: 2010, 
            max: 2016,
            variables: [
            { name: "DP05_0075E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population!!Not Hispanic or Latino!!Asian alone", type: "num" },
            { name: "DP05_0065E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population", type: "denom" }
            ]
        },
        {
            min: 2017, 
            max: 2021,
            variables: [
            { name: "DP05_0080E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population!!Not Hispanic or Latino!!Asian alone", type: "num" },
            { name: "DP05_0070E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Non-white (percent)", table: "ACS DEMOGRAPHIC AND HOUSING ESTIMATES", source: 'acs/acs5/profile', category: "race_vars",
        time_period: [
        {
            min: 2010, 
            max: 2016,
            variables: [
            { name: "DP05_0072E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population!!Not Hispanic or Latino!!White alone", type: "num" },
            { name: "DP05_0065E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population", type: "denom" }
            ]
        },
        {
            min: 2017, 
            max: 2021,
            variables: [
            { name: "DP05_0077E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population!!Not Hispanic or Latino!!White alone", type: "num" },
            { name: "DP05_0070E", label: "Estimate!!HISPANIC OR LATINO AND RACE!!Total population", type: "denom" }
            ]
        }
        ]
    },
    {
        indicator: "Total population (race)", table: "TOTAL POPULATION", source: 'acs/acs5',  category: "race_vars",
        time_period: [
        {
            min: 2010, 
            max: 2021,
            variables: [
            { name: "B01003_001E", label: "Estimate!!Total", type: "num" }
            ]
        }
        ]
    }
    ];
    
    
    //---------------------------------------------------------------------------//
    // setting up UI
    //---------------------------------------------------------------------------//

    // populate indicator dropdown

    var options = $("#ind_options");
    
    $.each(census_param, function (i, d) {
        options.append($("<option />").val(i).text(d.indicator));
    });
    
    
    //===========================================================================//
    // helper functions
    //===========================================================================//
    
    //---------------------------------------------------------------------------//
    // fetch with timeout
    //---------------------------------------------------------------------------//

    // from https://dmitripavlutin.com/timeout-fetch-request/
    
    async function fetchWithTimeout(resource, options = {}) {
        const { timeout = 8000 } = options;
        
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(resource, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(id);
        return response;
    }

    // fetch with timeout and retries

    var fetch_rt = fetchRetry(fetchWithTimeout);
    
    //---------------------------------------------------------------------------//
    // turn HTML table into JS table
    //---------------------------------------------------------------------------//
    
    // taken from https://gist.github.com/mattheo-gist/4151867

    function tableToObj(table) {

        var rows = table.rows;
        var propCells = rows[0].cells;
        var propNames = [];
        var results = [];
        var obj, row, cells;
        
        // Use the first row for the property names
        // Could use a header section but result is the same if
        // there is only one header row
        for (var i=0, iLen=propCells.length; i<iLen; i++) {
            propNames.push(propCells[i].textContent || propCells[i].innerText);
        }
        
        // Use the rows for data
        // Could use tbody rows here to exclude header & footer
        // but starting from 1 gives required result
        for (var j=1, jLen=rows.length; j<jLen; j++) {
            cells = rows[j].cells;
            obj = {};
            
            for (var k=0; k<iLen; k++) {
                obj[propNames[k]] = cells[k].textContent || cells[k].innerText;
            }
            results.push(obj)
        }
        return results;
    }

    //---------------------------------------------------------------------------//
    // make Arquero table
    //---------------------------------------------------------------------------//
    
    // turn html table into array, convert to Arquero, sort, then replace table element

    function make_arq_table() {

        GeoType_order = 
            aq.table({
                GeoType: [
                    "Citywide",
                    "Borough",
                    "Subboro",
                    "UHF42",
                    "CD",
                    "NTA2010",
                    "NTA2020"
                ],
                GeoType_order: [
                    1, 2, 3, 4, 5, 6, 7
                ]
            })

        datatableCsv = document.getElementById("datatableCsv");
        table_obj = tableToObj(datatableCsv);
        
        arq_table = aq.from(table_obj);
        
        arq_table = 
            arq_table
            .join_left(GeoType_order, "GeoType")
            .orderby(
                "IndicatorName", 
                "TimePeriod",
                "GeoType_order", 
                "GeoEntity", 
                "MeasureType"
            )
            .select(aq.not("GeoType_order"))

        // easy way to center all columns in "toHTML"

        var colnames_arr = Array.from(arq_table.columnNames(), name => [name, "c"]);
        var colnames_obj = Object.fromEntries(colnames_arr);

        document.getElementById('datatableCsv').innerHTML = arq_table.toHTML({limit: Infinity, align: colnames_obj, style: {table: "font-weight: normal;"}}); // print dataTable to HTML
        
    }

    //===========================================================================//
    // main data functions
    //===========================================================================//

    //---------------------------------------------------------------------------//
    // getdata (which calls hit_api with the correct indicator(s))
    //---------------------------------------------------------------------------//
    
    var datatableCsv;
    var table_obj;
    var arq_table;
    
    function getdata(i_val, y_val) {

        console.log("census_param[i_val]", census_param[i_val]);

        // if this is the Race and ethnicity indicator, or the transportation indicator, loop through the constituent indicators

        if (census_param[i_val].category === "race_vars") {
        
            race_vars.forEach(indicator => hit_api(indicator, y_val));
        }
        else if (census_param[i_val].category === "transportation") {
        
            transportation.forEach(indicator => hit_api(indicator, y_val));
        }
        else {
            
            hit_api(census_param[i_val], y_val);
        }

    }

    //---------------------------------------------------------------------------//
    // hit_api (which constructs API calls from paramaters)
    //---------------------------------------------------------------------------//
    
    var nta_data_in_geo;
    
    async function hit_api(this_ind, year) {

        console.log("this_ind", this_ind);

        // reset this value each time we hit the API

        nta_data_in_geo = {};
        
        // filter the time period by selected year to get the correct variables

        var census_var = this_ind.time_period.filter(time => year >= time.min && year <= time.max)[0].variables;
        var indicator = this_ind.indicator;
        var category = this_ind.category;

        // delete old table
        $('#tab_loc').empty();

        // create table and add header corresponding to EPHT Indicator Tool input fields
        $('#tab_loc').append('<table id="datatableCsv">');

        var row = $('<tr>');
        var this_url = api_url + '/' + year + '/' + this_ind.source + '?';

        row.append($('<th>').text('IndicatorName'));
        row.append($('<th>').text('MeasureType'));
        row.append($('<th>').text('GeoType'));
        row.append($('<th>').text('GeoEntity'));
        row.append($('<th>').text('TimePeriod'));
        row.append($('<th>').text('DataValue'));
        row.append($('<th>').text('UnreliabilityFlag'));
        row.append($('<th>').text('ConfidenceInterval'));
        $('#tab_loc table').append(row);
        
        
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
        // constructing paths
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

        // ---- COUNTY PATH ---- //

        var county = $.map(county2boro, function (n, i) { return n.county; });
        var county_path = this_url + "key=" + my_key + "&get=";
        for (i = 0; i < census_var.length; ++i) {
            county_path += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
        }
        county_path += "&for=county:" + county.toString() + "&in=state:36";
        
        // ---- ZCTA PATH ---- //

        var zcta = $.map(zcta2UHF, function (n, i) { return n.ZCTA; });
        var zcta_path = this_url + "key=" + my_key + "&get=";
        for (i = 0; i < census_var.length; ++i) {
            zcta_path += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
        }

        // starting in 2020, ZCTA doesn't need state - if you give state, it won't work

        if (year <= 2019) {
            zcta_path += "&for=zip+code+tabulation+area:" + zcta.toString() + "&in=state:36";
        } else {
            zcta_path += "&for=zip+code+tabulation+area:" + zcta.toString();
        }
        
        // ---- PUMA PATH ---- //

        var puma = $.map(puma2subboro, function (n, i) { return n.PUMA; });
        var puma_path = this_url + "key=" + my_key + "&get=";
        for (i = 0; i < census_var.length; ++i) {
            puma_path += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
        }
        puma_path += "&for=public+use+microdata+area:" + puma.toString() + "&in=state:36";
        
        // ---- PUMA CD ---- //

        var pumacd = $.map(puma2subboro, function (n, i) { return n.PUMA; });
        var puma_path_cd = this_url + "key=" + my_key + "&get=";
        for (i = 0; i < census_var.length; ++i) {
            puma_path_cd += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
        }
        puma_path_cd += "&for=public+use+microdata+area:" + pumacd.toString() + "&in=state:36";
        

        // switching apths depneding on year, to get NTA 2020

        if (year < 2020) {
            
            // ---- BX ---- //
            
            var nta2010BX = $.map(tractToNTA2010BX, function (n, i) { return n.TRACT; });
            var nta2010_pathBX = this_url + "key=" + my_key + "&get=";
            for (i = 0; i < census_var.length; ++i) {
                nta2010_pathBX += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
            }
            nta2010_pathBX += "&for=tract:" + nta2010BX.toString() + "&in=state:36+county:005";
            
            // ---- BK ---- //
            
            var nta2010BK = $.map(tractToNTA2010BK, function (n, i) { return n.TRACT; });
            var nta2010_pathBK = this_url + "key=" + my_key + "&get=";
            for (i = 0; i < census_var.length; ++i) {
                nta2010_pathBK += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
            }
            nta2010_pathBK += "&for=tract:" + nta2010BK.toString() + "&in=state:36+county:047";
            
            // ---- MN ---- //
            
            var nta2010MN = $.map(tractToNTA2010MN, function (n, i) { return n.TRACT; });
            var nta2010_pathMN = this_url + "key=" + my_key + "&get=";
            for (i = 0; i < census_var.length; ++i) {
                nta2010_pathMN += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
            }
            nta2010_pathMN += "&for=tract:" + nta2010MN.toString() + "&in=state:36+county:061";
            
            // ---- QN ---- //
            
            var nta2010QN = $.map(tractToNTA2010QN, function (n, i) { return n.TRACT; });
            var nta2010_pathQN = this_url + "key=" + my_key + "&get=";
            for (i = 0; i < census_var.length; ++i) {
                nta2010_pathQN += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
            }
            nta2010_pathQN += "&for=tract:" + nta2010QN.toString() + "&in=state:36+county:081";
            
            // ---- SI ---- //
            
            var nta2010SI = $.map(tractToNTA2010SI, function (n, i) { return n.TRACT; });
            var nta2010_pathSI = this_url + "key=" + my_key + "&get=";
            for (i = 0; i < census_var.length; ++i) {
                nta2010_pathSI += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
            }
            nta2010_pathSI += "&for=tract:" + nta2010SI.toString() + "&in=state:36+county:085";
            
        }
        
        
        if (year >= 2020) {
            
            // ---- BX ---- //
            
            var nta2020BX = $.map(tractToNTA2020BX, function (n, i) { return n.TRACT; });
            var nta_pathBX = this_url + "key=" + my_key + "&get=";
            for (i = 0; i < census_var.length; ++i) {
                nta_pathBX += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
            }
            nta_pathBX += "&for=tract:" + nta2020BX.toString() + "&in=state:36+county:005";
            
            // ---- BK ---- //
            
            var nta2020BK = $.map(tractToNTA2020BK, function (n, i) { return n.TRACT; });
            var nta_pathBK = this_url + "key=" + my_key + "&get=";
            for (i = 0; i < census_var.length; ++i) {
                nta_pathBK += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
            }
            nta_pathBK += "&for=tract:" + nta2020BK.toString() + "&in=state:36+county:047";
            
            // ---- MN ---- //
            
            var nta2020MN = $.map(tractToNTA2020MN, function (n, i) { return n.TRACT; });
            var nta_pathMN = this_url + "key=" + my_key + "&get=";
            for (i = 0; i < census_var.length; ++i) {
                nta_pathMN += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
            }
            nta_pathMN += "&for=tract:" + nta2020MN.toString() + "&in=state:36+county:061";
            
            // ---- QN ---- //
            
            var nta2020QN = $.map(tractToNTA2020QN, function (n, i) { return n.TRACT; });
            var nta_pathQN = this_url + "key=" + my_key + "&get=";
            for (i = 0; i < census_var.length; ++i) {
                nta_pathQN += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
            }
            nta_pathQN += "&for=tract:" + nta2020QN.toString() + "&in=state:36+county:081";
            
            // ---- SI ---- //
            
            var nta2020SI = $.map(tractToNTA2020SI, function (n, i) { return n.TRACT; });
            var nta_pathSI = this_url + "key=" + my_key + "&get=";
            for (i = 0; i < census_var.length; ++i) {
                nta_pathSI += (i == (census_var.length - 1)) ? census_var[i].name : census_var[i].name + ",";
            }
            nta_pathSI += "&for=tract:" + nta2020SI.toString() + "&in=state:36+county:085";
            
        }
        
        
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
        // get and parse json
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

        // unnested so asynchronous; all requests happen in parrallel = much faster
        // "make_arq_table" reconstructs the originally intended row order

        // "await Promise.all" will pause execution of "hit_api" until all the downloading and parsing is complete, which 
        //  allows for the whole table to be constructed before converting it into an array and then into an Arquero table
        //  with "make_arq_table"
        
        await Promise.all([
            fetch_rt(county_path).then(res => res.json()).then(city_json => parse_json(census_var, indicator, category, year, city_json, "county", 'county', 'Citywide', county2boro)),
            fetch_rt(county_path).then(res => res.json()).then(county_json => parse_json(census_var, indicator, category, year, county_json, "county", 'county', 'Borough', county2boro)),
            fetch_rt(puma_path).then(res => res.json()).then(puma_json => parse_json(census_var, indicator, category, year, puma_json, "public use microdata area", 'PUMA', 'Subboro', puma2subboro)),
            fetch_rt(zcta_path).then(res => res.json()).then(zcta_json => parse_json(census_var, indicator, category, year, zcta_json, "zip code tabulation area", 'ZCTA', 'UHF42', zcta2UHF)),
            fetch_rt(puma_path_cd).then(res => res.json()).then(cd_json => parse_json(census_var, indicator, category, year, cd_json, "public use microdata area", 'PUMA', 'CD', puma2subboro)),
            fetch_rt(nta_pathBX).then(res => res.json()).then(BX_nta_json => parse_json(census_var, indicator, category, year, BX_nta_json, "tract", 'TRACT', year < 2020 ? 'NTA2010' : 'NTA2020', year < 2020 ? tractToNTA2010BX : tractToNTA2020BX)),
            fetch_rt(nta_pathBK).then(res => res.json()).then(BK_nta_json => parse_json(census_var, indicator, category, year, BK_nta_json, "tract", 'TRACT', year < 2020 ? 'NTA2010' : 'NTA2020', year < 2020 ? tractToNTA2010BK : tractToNTA2020BK)),
            fetch_rt(nta_pathMN).then(res => res.json()).then(MN_nta_json => parse_json(census_var, indicator, category, year, MN_nta_json, "tract", 'TRACT', year < 2020 ? 'NTA2010' : 'NTA2020', year < 2020 ? tractToNTA2010MN : tractToNTA2020MN)),
            fetch_rt(nta_pathQN).then(res => res.json()).then(QN_nta_json => parse_json(census_var, indicator, category, year, QN_nta_json, "tract", 'TRACT', year < 2020 ? 'NTA2010' : 'NTA2020', year < 2020 ? tractToNTA2010QN : tractToNTA2020QN)),
            fetch_rt(nta_pathSI).then(res => res.json()).then(SI_nta_json => parse_json(census_var, indicator, category, year, SI_nta_json, "tract", 'TRACT', year < 2020 ? 'NTA2010' : 'NTA2020', year < 2020 ? tractToNTA2010SI : tractToNTA2020SI))
        ])

        // turn into arquero table, etc., and replace original html table
        
        make_arq_table();

    }

    //---------------------------------------------------------------------------//
    // parse_json
    //---------------------------------------------------------------------------//

    function parse_json(census_var, indicator, category, year, c_json, c_geo, from_geo, to_geo, geos) {
        
        // create table from Geo to geo table according to lookup
        var geoOL = {};
        $.each(geos, function (i, val) {
            geoOL[geos[i][from_geo]] = geos[i][to_geo];
        });
        
        // grab variable names // Get all title for Key value pair
        var c_var = c_json.shift();
        
        // assign variable names as keys 
        //  Assign key value accoridng to c_var table= table name, state=

        var cdata2 = []; // again all data with object key value

        for (i = 0; i < c_json.length; ++i) {
            var c = c_json[i];
            var temp_OL = {};
            for (j = 0; j < c.length; ++j) {
                temp_OL[c_var[j]] = c[j];
            }
            cdata2.push(temp_OL);
        }
        
        // get type for each variable name 
        // table name with num or denonminator assignmrnt type_OL

        var type_OL = {};

        for (i = 0; i < census_var.length; ++i) {
            type_OL[census_var[i].name] = census_var[i].type;
        }
        
        // create object for each geographic entity with variables summed by type
        var cdata = {};

        for (i = 0; i < cdata2.length; ++i) {

            var temp_OL = {};
            var p = cdata2[i];

            for (var key in p) {

                // all data arrary will itrate
                if (p.hasOwnProperty(key)) {

                    // only take table values
                    if (type_OL.hasOwnProperty(key)) {

                        if (temp_OL.hasOwnProperty(type_OL[key])) {
                            temp_OL[type_OL[key]] = temp_OL[type_OL[key]] + parseInt(p[key]);
                        }
                        else {
                            temp_OL[type_OL[key]] = parseInt(p[key]);
                        }
                    }
                }
            }
            temp_OL[to_geo] = geoOL[p[c_geo]];
            cdata[p[c_geo]] = temp_OL;
        }
        
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
        // aggregate by geography
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

        var data_in_geo = {};

        for (var key1 in cdata) {

            var key = cdata[key1][to_geo];

            if (!data_in_geo[key]) {
                data_in_geo[key] = {};
            }

            for (var key2 in cdata[key1]) {

                if (key2 !== to_geo) {
                    if (!data_in_geo[key][key2]) {
                        data_in_geo[key][key2] = parseInt(cdata[key1][key2]);
                    }
                    else {
                        data_in_geo[key][key2] += parseInt(cdata[key1][key2]);
                    }
                }
            }
        }
        
        // call calculation and display functions

        var data_in_geo = populate_stats(data_in_geo, indicator, category)
        DrawTable(data_in_geo, to_geo, year, indicator, category);
        
    }
    
        
    //---------------------------------------------------------------------------//
    // populate_stats
    //---------------------------------------------------------------------------//
    
    // I added a bunch of logic so that the Race and ethnicity indicator is exported 
    //  in the format that the portal is expecting (i.e., race group as measure).
    
    function populate_stats(data_in_geo, indicator, category) {
        
        var dataNumber = [];
        var dataPercent = [];
        var range_array = [];
        var leg_no = 3;
        var ranks = [];
        var ranksPer = [];

        for (var key in data_in_geo) {
            
            // if race indicator, don't print number
            
            if (category !== "race_vars") {
                
                var temp_OL = data_in_geo[key];
                dataNumber.push(temp_OL["num"]);

            }
        }
        
        for (var key in data_in_geo) {

            var temp_OL = data_in_geo[key];

            // rename indicator to Race and ethnicity, remove "Number", replace "Percent" with "Percent [race indicator]""

            if (indicator == "Child poverty (under age 5)") {

                var test_ind = d3.format(".2f")(100 * (temp_OL["num"] / (temp_OL["denom2"] + temp_OL["num"])));

                if (!isNaN(test_ind)) {
                    dataPercent.push(test_ind);
                }
                else {
                    dataPercent.push(0);
                }
            }
            else if (indicator === "Non-white (percent)") {
                
                // literally total population minus white-alone
                var test_ind = d3.format(".2f")(100 * ((temp_OL["denom"] - temp_OL["num"]) / temp_OL["denom"]));

                if (!isNaN(test_ind)) {
                    dataPercent.push(test_ind);
                }
                else {
                    dataPercent.push(0);
                }
            }
            else if (indicator === "Total population" || indicator === "Poverty TOTAL" || indicator === "Housing Units") {

                // don't push anything to dataPercent, b/c only num matters

            }
            else if (!temp_OL["denom"]) {

                var test_ind = d3.format(".2f")(100 * (temp_OL["num"] / temp_OL["denom2"]));

                if (!isNaN(test_ind)) {
                    dataPercent.push(test_ind);
                }
                else {
                    dataPercent.push(0);
                }
            }
            else {

                var test_ind = d3.format(".2f")(100 * (temp_OL["num"] / temp_OL["denom"]));

                if (!isNaN(test_ind)) {
                    dataPercent.push(test_ind);
                }
                else {
                    dataPercent.push(0);
                }
            }
        }
        
        data_quantile = d3.scaleQuantile();
        data_quantile.domain(dataNumber);
        
        range_array.length = 0;
        for (i = 0; i < leg_no; i++) {
            range_array[i] = i + 1
        }
        
        data_quantile.range(range_array);
        for (var i = 0; i < dataNumber.length; i++) {
            var f = dataNumber[i];
            var q = data_quantile(f);
            ranks.push(q);
        }
        
        var i = 0;
        for (var key in data_in_geo) {
            data_in_geo[key]["rank"] = ranks[i];
            i++;
        }
        
        // percent disparity
        data_quantile.domain(dataPercent);
        for (var i = 0; i < dataPercent.length; i++) {
            var f = dataPercent[i];
            var q = data_quantile(f);
            ranksPer.push(q);
        }

        // Add to orignal node
        var i = 0;
        for (var key in data_in_geo) {
            data_in_geo[key]["rankper"] = ranksPer[i];
            i++;
        }

        console.log("data_in_geo", data_in_geo);
        
        return data_in_geo;
        
    }
    

    //---------------------------------------------------------------------------//
    // DrawTable
    //---------------------------------------------------------------------------//

    // I added a bunch of logic so that the Race and ethnicity indicator is exported 
    //  in the format that the portal is expecting (i.e., race group as measure).

    function DrawTable(data_in_geo, to_geo, year, indicator, category) {

        // table only clears when hit_api is called, so looping through race indicators just keeps appending rows. 
        //  export functions take data from the html table, so everything works.
        
        for (var key in data_in_geo) {

            var keyArray = key.split(',');
            // cd devide logic

            for (var i = 0; i < keyArray.length; i++) {
                
                var temp_OL = data_in_geo[key];
                var row = $('<tr>');

                //---------------------------------------------------//
                // number
                //---------------------------------------------------//
                
                // if race indicator, don't print number

                if (category !== "race_vars") {

                    if (indicator === "Total population (race)") {
                        
                        row.append($('<td>').text("Race and ethnicity"));               // IndicatorName
                        row.append($('<td>').text(indicator.replace(" \(Race\)", ""))); // MeasureType
                        
                    } else if (category === "transportation") {
                        
                        row.append($('<td>').text("Means of transportation to work"));  // IndicatorName
                        row.append($('<td>').text("Number: " + indicator));   // MeasureType
                        
                    } else {
                        
                        row.append($('<td>').text(indicator));   // IndicatorName
                        row.append($('<td>').text('Number'));   // MeasureType
                    }
                    
                    row.append($('<td>').text(to_geo));         // GeoType
                    row.append($('<td>').text(keyArray[i]));    // GeoEntity
                    row.append($('<td>').text((year - 4) + '-' + (year - 2000))); // TimePeriod
                    row.append($('<td>').text(temp_OL["num"])); // DataValue
                    row.append($('<td>').text('0'));            // UnreliabilityFlag
                    row.append($('<td>').text(''));             // ConfidenceInterval
                    
                    $('#tab_loc table').append(row);
                    
                }

                var row = $('<tr>');
                
                // might be able to replace these duplicated calculations by declaring a `test_ind` var inside of `parse_json`. would be available to
                //  later functions.
                
                if (indicator === "Child poverty (under age 5)") {
                    
                    var test_ind = d3.format(".2f")(100 * (temp_OL["num"] / (temp_OL["denom2"] + temp_OL["num"])));
                    
                }
                else if (indicator === "Non-white (percent)") {
                    
                    // literally total population minus white-alone
                    var test_ind = d3.format(".2f")(100 * ((temp_OL["denom"] - temp_OL["num"]) / temp_OL["denom"]));
                }
                else if (indicator === "Total population" || indicator === "Poverty TOTAL" || indicator === "Housing Units") {

                    // don't do anything b/c num already displayed
                    // var test_ind = null;
                    
                }
                else if (!temp_OL["denom"]) {
                    
                    var test_ind = d3.format(".2f")(100 * (temp_OL["num"] / temp_OL["denom2"]));
                }
                else {
                    
                    var test_ind = d3.format(".2f")(100 * (temp_OL["num"] / temp_OL["denom"]));
                }

                //---------------------------------------------------//
                // percent
                //---------------------------------------------------//

                // if indicator is a total, don't show percent (aka, if indicator isn't a total, show percent)

                if (!indicator.startsWith("Total population") && indicator !== "Poverty TOTAL" && indicator !== "Housing Units") {
                    
                    // if this is a race indicator, replace "Percent" with the indicator name, and replace 
                    //  the indicator name with "Race and ethnicity"

                    if (category === "race_vars") {
                        
                        row.append($('<td>').text("Race and ethnicity"));  // IndicatorName
                        row.append($('<td>').text(indicator));             // MeasureType
                        
                    } else if (category === "transportation") {

                        row.append($('<td>').text("Means of transportation to work"));  // IndicatorName
                        row.append($('<td>').text("Percent: " + indicator));            // MeasureType
                        
                    } else {

                        row.append($('<td>').text(indicator));   // IndicatorName
                        row.append($('<td>').text('Percent'));   // MeasureType
                    }

                    row.append($('<td>').text(to_geo));       // GeoType
                    row.append($('<td>').text(keyArray[i]));  // GeoEntity
                    row.append($('<td>').text((year - 4) + '-' + (year - 2000)));  // TimePeriod
                    
                    if (!isNaN(test_ind)) {
                        row.append($('<td>').text(test_ind));  // DataValue
                    }
                    else {
                        row.append($('<td>').text(0));  // DataValue
                    }
                    
                    row.append($('<td>').text('0'));  // UnreliabilityFlag
                    row.append($('<td>').text(''));   // ConfidenceInterval
                    
                    $('#tab_loc table').append(row);


                }
                
                if (to_geo != 'Citywide' && document.getElementById("chkrank").checked ) {
                      if (to_geo != 'Borough' && document.getElementById("chkrank").checked) {
                        var row = $('<tr>');
                        row.append($('<td>').text(indicator));          // IndicatorName
                        row.append($('<td>').text('Rank'));             // MeasureType
                        row.append($('<td>').text(to_geo));             // GeoType
                        row.append($('<td>').text(keyArray[i]));        // GeoEntity
                        row.append($('<td>').text((year - 4) + '-' + (year - 2000))); // TimePeriod
                        row.append($('<td>').text(temp_OL["rankper"])); // DataValue
                        row.append($('<td>').text('0'));                // UnreliabilityFlag
                        row.append($('<td>').text(''));                 // ConfidenceInterval
                        $('#tab_loc table').append(row);
                    }
                }
            }
        }

    }
    
    
    //---------------------------------------------------------------------------//
    // get and download
    //---------------------------------------------------------------------------//
    
    // function to download as CSV from http://jsfiddle.net/terryyounghk/KPEGU/
    
    $(document).ready(function () {
        
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
        // exportTableToCSV
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
        
        // this downloads the data from the html table
        
        function exportTableToCSV(arq_table, filename) {
            
            csv = arq_table.toCSV();
            
            // Data URI
            csvData = 'data:application/csv;charset=utf-8,' + encodeURIComponent(csv);
            
            $(this)
            .attr({
                'download': filename,
                'href': csvData,
                'target': '_blank'
            });
        }
        
        
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
        // get data (and set indicator & year options)
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

        var iy_vals = [];
        var ind;
        
        $("#get_data").click(function (event) {

            event.preventDefault();
            
            /*             
            setting indicator and year values when the "Get Data" button is clicked. Because 
            of the assignment to `iy_vals`, they persist and are readable by the export 
            function when the "Export" button is clicked. This allows us to save files 
            named with indicator and year, but also ensure that they're the same values
            that are in the data we downloaded. 
            */
            
            var ind = document.getElementById("ind_options");
            var i_val = ind.options[ind.selectedIndex].value;
            
            var yr = document.getElementById("year_options");
            var y_val = yr.options[yr.selectedIndex].value;
            
            getdata(i_val, y_val);
            
            iy_vals = [i_val, y_val]
            
        });
        
        
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
        // export
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

        // This must be a hyperlink
        $("#exportChrome").on('click', function () {
            
            var year = iy_vals[1];
            var indicator = census_param[iy_vals[0]].indicator
            
            exportTableToCSV.apply(this, [arq_table, 'ACS ' + indicator + ' ' + year + '.csv']);
            
        });
        
        
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
        // set BrowserDetect
        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

        $(document).ready(function () {
            
            var BrowserDetect = {
                init: function () {
                    this.browser = this.searchString(this.dataBrowser) || "Other";
                    this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "Unknown";
                },
                searchString: function (data) {
                    for (var i = 0; i < data.length; i++) {
                        var dataString = data[i].string;
                        this.versionSearchString = data[i].subString;
                        
                        if (dataString.indexOf(data[i].subString) !== -1) {
                            return data[i].identity;
                        }
                    }
                },
                searchVersion: function (dataString) {
                    var index = dataString.indexOf(this.versionSearchString);
                    if (index === -1) {
                        return;
                    }
                    
                    var rv = dataString.indexOf("rv:");
                    if (this.versionSearchString === "Trident" && rv !== -1) {
                        return parseFloat(dataString.substring(rv + 3));
                    } else {
                        return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
                    }
                },
                
                dataBrowser: [
                    { string: navigator.userAgent, subString: "Edge", identity: "MS Edge" },
                    { string: navigator.userAgent, subString: "MSIE", identity: "Explorer" },
                    { string: navigator.userAgent, subString: "Trident", identity: "Explorer" },
                    { string: navigator.userAgent, subString: "Firefox", identity: "Firefox" },
                    { string: navigator.userAgent, subString: "Opera", identity: "Opera" },
                    { string: navigator.userAgent, subString: "OPR", identity: "Opera" },
                    { string: navigator.userAgent, subString: "Chrome", identity: "Chrome" },
                    { string: navigator.userAgent, subString: "Safari", identity: "Safari" }
                ]
            };
            
            BrowserDetect.init();
            if (BrowserDetect.browser == "Explorer") {
                $("#exportIE").show();
            }
            else {
                $("#exportChrome").show();
            }
        });
        
    });
    
</script>
